# ViDARs(VisualisedDetectionAndRanging system)

## OverAll

**座標系は右手系！！！**

ステージ上に表示される主人公を中心に、一定範囲のメッシュを探知し、レーダー画面(Polar Graph)に表示する

## DetectionAndRanging

### 方針

- 兵装制御システムにとってのセンサー : ゲームシステム

- プレイヤーにとっての戦況把握 : プレイヤー

- 視覚トリックのようなゲームアイデアと雰囲気作り : コンテンツ

上記3つの性質をあわせもつこと

コリジョンメッシュに対するプレイヤー視点からのレイキャスティングで実装される

- 拡張性を踏まえ一部処理は3Dで実装しているが、コリジョンメッシュは2Dで実装する

照射されるレイの種類、メッシュの各種Attrubute、速度、回転、角度、距離に応じた信号強度の変化

- 但し「反射波」というものは厳密にいうと存在しない
- レイキャストを行った際に上記のパラメータから信号強度が決定される
- あくまで1段階のレイキャスティングであり、反射などを扱うレイトレーシングではない

### 実装

方針変更(23/11/12 17:00)
走査面補間が線形だと誤差が(特に近距離で)大きく、球面との差分の補正を行わなければならない

これが普通に計算重くて(更新するグリッド数に比例する)、レイキャスティングの方が良いのでは？となっている

ポリゴン分解

- [x] 全オブジェクトのメッシュをポリゴンに分解(これはオブジェクト生成時に予め行う)

走査面(線)生成 **現時点(23/11/12)では2D走査線生成のみ対応**

- [x] 走査頂点をプレイヤーオブジェクトの中心点から同一半径で一定間隔毎に展開
- [x] 隣り合う頂点から走査グリッド(空のVector{Flot})を生成

**以下は全て"2D"で"各フレーム毎"に行う!!!**

**基本的に3Dポリゴン前提で関数を作っているので、2Dポリゴンを作る際には、3つ目の頂点座標を2つ目の頂点座標と一致させる!!!!!**
  
- CalcNormalVectorで外積使って法線ベクトル求める部分もここにあわせている

投影(幾何学的情報のみ)

- [x] 各オブジェクトのポリゴンをグローバル座標へ変換
  - 平行移動後Quaternionで回転させた
  - ここ、3Dポリゴンを仮定してハードコードしてるから、2Dポリゴンを作る際には上記のことに注意 
- [x] この際に中心点から各頂点へのベクトルを算出
- [x] 距離とキャラクターオブジェクトとの内積・外積から頂点が走査範囲内か確認
- [x] 全ての頂点が一定範囲外ならその時点で処理を終了
- [x] 範囲内の頂点については上述の通りポリゴン頂点の探知位置ピクセルを決定
- [x] ポリゴン走査終了時点で線形補間を実行、頂点に囲まれた範囲を距離を与えて埋める
- [x] この時点では他のメッシュに隠れるはずの対象もR-bufferに蓄えられていることに注意

カリング＆ラスタライズ(幾何学的情報のみ)

- [ ] カメラ座標変換後の距離を基に、R-bufferに蓄えられた対象から探知対象を1つに絞る
- [ ] この段階で、線形補間によって探知範囲外の対象をピクセルに蓄えていた場合は消去

ピクセルシェーダ(各種Attributeを使う)

- [ ] 本来は主に色付けや透明度情報の反映が行われる
- [ ] ViDARSでは「反射強度」が角度、表面ラフネス、反射スペクトルから定まる
- [ ] 更に、速度情報からドップラー方式により運動情報も各ピクセルに加わる

## Visualiser

距離を基に角ピクセル毎にどの位置に表示するかを選択

速度情報から色分けも可能になる

## DepthBufferかRayCastingか

### DepthBuffer(VertexCasting)

利点

- 計算量が少ない(オブジェクト頂点を射影してきて補間するだけなので$O(N)$のはず)
  - 但し、球面上にキャストする今回は線形補間ではなく中心からの角度$\theta$を用いて$cos(\theta)$を各要素に掛けなければならない為、最悪計算量は$O(N^2)$に達する？
  - 並列性を上げれば計算量は戻るがそれはRayCastingにも言える

欠点

- やや汎用性に欠ける
  - レーダー上描画以外のタスクに殆ど応用できない
  - このシステムは「描画するだけ」に留めるには惜しいと思っているのでこれは大きなマイナス

### RayCasting

利点

- 汎用性・拡張性が高い
  - 所謂レイトレーシングに繋げられるので、DepthBuffer法では実装できていない反射波の影響なども容易にできる
  - しかもレーザーとかも同じような方法でコリジョンを取れる上、レイトレーシングとAttributeの影響反映を応用すれば跳弾の実装も容易と、いろんな遊びを提供できる

- 実は実装がシンプル
  - やってみてわかったが、実は2次元だと特にRayCastingの方が圧倒的にシンプル
  - やってることは一定角度毎に線を引いて交点求めて距離取って既存の格納データと比べて小さかったらそれを格納、というだけな上、所謂エッジケースで悩まされないからめちゃ楽

欠点

- 重い(はず)
  - 計算量は$O(N^2)$、しかも各Ray、各Polygon毎に判定を取るため常にこの計算量が必要