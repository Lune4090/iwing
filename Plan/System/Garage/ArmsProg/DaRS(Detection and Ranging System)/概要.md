#### DaRS
- ステージ上に表示される主人公を中心に、一定範囲のメッシュを探知し、レーダー(Polar Graph)に表示する
    - 実装
        - メッシュは判定には使用する
            - 多分重くなるし、Rayを飛ばさないといけなくなってMakieの既存機能だと対応できないと思うできた
        - Non-phased-array Radar
            - way 1 - Search & 2D-R-buffer (without collision calc)
            - OpenGLのZ-bufferを利用したレンダリングパイプラインを参考にした2D-R-buffer法を採用
                    - 実装
		                - Searching
	                    - 頂点シェーダ：Searchingに引っかかった各オブジェクトについて、ローカル座標からワールド座標へ各メッシュの頂点を変換
	                    - 投影：更にカメラ座標へ変換(ウィンドウに向け各頂点を射影、頂点の描画ピクセルを決定、この時点ではR-bufferに渡される)
	                    - カリング：カメラ座標変換後の深度値を基に見えないポリゴンを描画対象から除外
	                    - ラスタライズ：投影処理で決まったピクセルから内部を補完し、ポリゴン全体をカメラ面上に描画可能な状態にする
	                    - ピクセルシェーダ：本来は主に色付けや透明度情報の反映が行われるが、レーダーシステムでは速度情報を渡してドップラー方式による動目標探知を可能にする
	                    - R-buffer：いわゆる深度バッファ、各頂点の距離をもとに、各ピクセル毎に描画する対象を選択
	                    - R-Extention：距離を基に角ピクセル毎にどの位置に表示するかを選択
	                    - メッシュ頂点にAttributeとして速度ベクトルを組み込み、ドップラー解析を可能にする
            - way 2 - Ray Casting (with Collision calc)
                - 所謂レイキャスティング
                - 実装
		                - Searching
		                - Searching対象のオブジェクトのコリジョンメッシュについて、各faceに走査点(既知)からRayを引き、交点を物体表面からの距離として計算する
		                - この時に各種Attributesも受け取る
                - 利点
                    - 探知漏れの問題は解消できる
                        - 上述の方法だとコリジョンを書いても、肝心のメッシュの情報を渡すのが難しいからダメ
                        - むしろこちらはメッシュを消しても良い分楽かもしれない
                    - 並列化に向く為高速化が容易
                - 欠点
                    - 方程式計算がやや面倒
                    - コリジョンの図形が複雑化するとその分遅くなる
            - meshscatter!()を使うのが任意の場所にmeshを置く一番いい方法か？